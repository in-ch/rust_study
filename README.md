# 3.1 변수와 가변성

### 변수와 가변성

> Rust에서 기본 변수는 불변성이다. 변수가 불변성인 경우, 일단 값이 bound되면 해당 값을 변경할 수 없다.
> 만약에 불변성으로 선언한 것의 값을 변경하고자 하는 시도를 하면 컴파일 타임의 에러를 얻게 된다.

- mut를 사용해서 불변성 변수를 가변성 변수로 변경할 수 있다.

<code>
fn main() {
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code>

### 변수와 상수 간의 차이점들

> 불변성 변수와 마찬가지로 상수 또한 이름으로 bound된 후에는 값의 변경이 허용되지 않지만, 상수와 변수는 조금 다르다.

1. 상수는 const 키워드를 사용해야 하며 mut를 허용하지 않는다. -> 불변성 그 자체이다.
2. 상수는 전체 영역을 포함하여 어떤 영역에서도 선언될 수 있다. -> 코드의 많은 부분에서 사용될 필요가 있는 값을 다루는데 유용하다.
3. 상수는 오직 상수 표현식만 설정될 수 있지, 함수 호출의 결과값이나 그 외의 실행 시간에 결정되는 값이 설정될 수 없다.
   ex)
   <code>
   const MAX_POINTS: u32 = 100_000;
   </code>

### Shadowing

> 이전에 선언한 변수와 같은 새 변수를 선언할 수 있고, 새 변수는 이전 변수를 shadows를 하게 된다. -> 러스트인들은 이를 첫 변수가 두 번째에 의해 shadowed 됐다고 표현한다.
> let 키워드를 사용해서 반복하여 같은 변수명으로 변수를 shadow할 수 있다.

다음 예제는 x에 처음 5를 bind를 하고 shadow하여 원본에 1를 더해서 6더하고 이런 식으로 반복한다.

<code>
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x + 2;

    println!("The value of x is: {}", x);

}
</code>

그런데 만약에 let를 사용하지 않고 mut로 선언하게 되면 컴파일 시 에러를 얻게 된다.

### mut과 let의 차이점

즉, 변수를 지속적으로 변하게 싶으면 let을 쓰고 변수를 새로 할당하고 싶으면 mut 키워드를 쓰면 될 것 같다.


# 3.2 
> 기억해야할 것은 Rust에는 변수가 어떤 형태의 데이터인지 명시해줘야한다. -> 타입은 고정적이다.
> 데이터의 타입은 크게 스칼라와 컴파운드, 둘로 나뉜다. 

1. 스칼라 

스칼라는 하나의 값으로 표현되는 타입이다. (정수, 부동소수점 숫자, boolean, 문자)

- 정수형 : 소수점이 없는 숫자이다. 2장에서는 u32타입인 정수형을 사용했었다. -> 부호 없는 32비트 변수임을 나타냄. -> 만약 부호가 있다면 i32처럼 u대신 i로 시작함. 

Length	Signed	Unsigned
------------------------
8-bit	i8	    u8
16-bit	i16	    u16
32-bit	i32	    u32
64-bit	i64	    u64
arch	isize	usize

여기서 부호, 미부호의 의미는 숫자가 양수 혹은 음수를 다룰 수 있는지 혹은 없는지를 나타낸다.  -> 만약 오직 양수만을 가질 것이면 부호가 없이도 표현할 수 있기 때문에 미부호로 나타낸다. 

각 부호 변수는 -(2n - 1) 부터 2n - 1 - 1 까지의 값을 포괄한다. 여기서 n은 사용되는 타입의 비트 수 입니다. 즉, i8은 -(27) 에서 27 - 1 까지의 값, 즉 -128 에서 127 사이의 값을 저장할 수 있다. 
미부호 타입은 0 에서 2n - 1 까지의 값을 저장할 수 있다. 즉, u8 타입은 0 에서 28 - 1 다시 말해, 0 에서 255 까지의 값을 저장할 수 있습니다.

isize와 usize 타입은 프로그램이 동작하는 컴퓨터 환경이 64-bits인지 32-bit인지에 따라 쓰인다. 

- 정수형 리터럴 

Number literals	    Example
---------------------------
Decimal	            98_222
Hex	                0xff
Octal	            0o77
Binary	            0b1111_0000
Byte (u8 only)	    b'A'

일반적인 경우에는 (심지어 64bit환경에서도) i32가 일반적으로 좋은 선택이다. 

- 부동 소수점 타입
32bit와 64bit의 크기를 가진 f32와 f64가 있다.

ex)
<code>
fn main() {
    let x = 2.0; // f64
    let y:f32 = 3.0; // f32
}
</code>
f32타입은 1배수의 정밀도인 부동소수점이고, f64는 2배수의 정밀도인 부동소수점이다. 

- 수학적 연산들 
let을 사용하면 rust가 알아서 산출된 값을 변수로 bound한다.

ex)
<code>
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code>

- Boolean 타입 

일반적인 다른 언어와 사용법이 같다. bool 키워드를 사용한다.

ex)
<code>
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code>

- 문자 타입 

''와 ""는 다르다. 
''는 Unicode Scalar를 표현하는 값이고 이는 한국어/중국어/일본어, 이모티콘 등 모두 사용 가능한 char 타입이다. -> ""와 ''의 차이점에 대해서는 8장 String에서 더 자세히 다룬다. 


- 복합 타입들 

튜플은 다양한 타입의 몇 개의 숫자를 집합시켜 하나의 복합 타입으로 만드는 일반적인 방법이다. 
괄호 안에 콤마로 구분되는 값들의 목록을 작성하여 튜플을 만든다. -> 다 달라도 된다.

ex)
<code>
fn main(){
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code>

튜플은 단일 요소를 위한 복합계로 고려되었기에 전체가 bind된다. 개별적으로 끄내기 위해서는 구조분해를 해야한다. 

ex)
<code>
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is : {}", y);
}
</code>

구조분해에 추가로 뒤에 마침표(.) 뒤에 접근하기 원하는 값의 색인을 넣는 것을 통해 튜플의 요소에 직접적으로 접근할 수 있다.

ex)
<code>
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;
}
</code>

뭔 배열에서 x[0]쓰는 것과 비슷하냐 ㅋㅋㅋㅋ 
당연히 튜플의 첫 번째 색인은 0이다. 

- 배열 

튜플과 다르게 배열의 모든 요소는 모두 같은 타입이여야 한다. 또한 고정된 길이를 갖게 되며 한번 선언되면 크기는 커지거나 작아지지 않는다. -> 가변적이게 사용하고 싶다면 8장에서 배우는 벡터를 사용해야 한다. 

ex)
<code>
fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code>

- 배열의 요소에 접근하기 

일반적인 방법과 같다. 
<code>
fn main(){
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code>

여기서 다른 언어와 다른 점은 만약 배열의 크기가 넘은 index을 호출할 경우 Rust는 프로그램이 오류와 함께 종료될 때 패닉한다. -> 메모리 접근을 허용하고 계속 진행하는 대신 즉시 종료한다. -> 실행 중에 에러가 나오는 것이다. 
